#include <iostream>
#include <vector>

#include <cstdlib>
#include <cstdio>
#include <cstdint>

#include "aes.h"

using namespace std;


/*
**  AES S-Box
*/

static const uint8_t SBOX[256] = {
	0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
	0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
	0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
	0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
	0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
	0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
	0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
	0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
	0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
	0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
	0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
	0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
	0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
	0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
	0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
	0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16
};
static const uint8_t *inverseLookupTable (const uint8_t table[256])
{
	static uint8_t reverse[256];
	for (int k = 0; k < 256; ++k)
		reverse[table[k]] = k;
	return reverse;
}
static const uint8_t *SBOX_INV = inverseLookupTable(SBOX);

static const uint8_t RCON[256] = {
	0x8D, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36, 0x6C, 0xD8, 0xAB, 0x4D, 0x9A,
	0x2F, 0x5E, 0xBC, 0x63, 0xC6, 0x97, 0x35, 0x6A, 0xD4, 0xB3, 0x7D, 0xFA, 0xEF, 0xC5, 0x91, 0x39,
	0x72, 0xE4, 0xD3, 0xBD, 0x61, 0xC2, 0x9F, 0x25, 0x4A, 0x94, 0x33, 0x66, 0xCC, 0x83, 0x1D, 0x3A,
	0x74, 0xE8, 0xCB, 0x8D, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36, 0x6C, 0xD8,
	0xAB, 0x4D, 0x9A, 0x2F, 0x5E, 0xBC, 0x63, 0xC6, 0x97, 0x35, 0x6A, 0xD4, 0xB3, 0x7D, 0xFA, 0xEF,
	0xC5, 0x91, 0x39, 0x72, 0xE4, 0xD3, 0xBD, 0x61, 0xC2, 0x9F, 0x25, 0x4A, 0x94, 0x33, 0x66, 0xCC,
	0x83, 0x1D, 0x3A, 0x74, 0xE8, 0xCB, 0x8D, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B,
	0x36, 0x6C, 0xD8, 0xAB, 0x4D, 0x9A, 0x2F, 0x5E, 0xBC, 0x63, 0xC6, 0x97, 0x35, 0x6A, 0xD4, 0xB3,
	0x7D, 0xFA, 0xEF, 0xC5, 0x91, 0x39, 0x72, 0xE4, 0xD3, 0xBD, 0x61, 0xC2, 0x9F, 0x25, 0x4A, 0x94,
	0x33, 0x66, 0xCC, 0x83, 0x1D, 0x3A, 0x74, 0xE8, 0xCB, 0x8D, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20,
	0x40, 0x80, 0x1B, 0x36, 0x6C, 0xD8, 0xAB, 0x4D, 0x9A, 0x2F, 0x5E, 0xBC, 0x63, 0xC6, 0x97, 0x35,
	0x6A, 0xD4, 0xB3, 0x7D, 0xFA, 0xEF, 0xC5, 0x91, 0x39, 0x72, 0xE4, 0xD3, 0xBD, 0x61, 0xC2, 0x9F,
	0x25, 0x4A, 0x94, 0x33, 0x66, 0xCC, 0x83, 0x1D, 0x3A, 0x74, 0xE8, 0xCB, 0x8D, 0x01, 0x02, 0x04,
	0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36, 0x6C, 0xD8, 0xAB, 0x4D, 0x9A, 0x2F, 0x5E, 0xBC, 0x63,
	0xC6, 0x97, 0x35, 0x6A, 0xD4, 0xB3, 0x7D, 0xFA, 0xEF, 0xC5, 0x91, 0x39, 0x72, 0xE4, 0xD3, 0xBD,
	0x61, 0xC2, 0x9F, 0x25, 0x4A, 0x94, 0x33, 0x66, 0xCC, 0x83, 0x1D, 0x3A, 0x74, 0xE8, 0xCB, 0x8D
};


/*
**  Precomputed multiplication in Galois field
*/

static const uint8_t GMUL_2[] = {
	0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0E, 0x10, 0x12, 0x14, 0x16, 0x18, 0x1A, 0x1C, 0x1E,
	0x20, 0x22, 0x24, 0x26, 0x28, 0x2A, 0x2C, 0x2E, 0x30, 0x32, 0x34, 0x36, 0x38, 0x3A, 0x3C, 0x3E,
	0x40, 0x42, 0x44, 0x46, 0x48, 0x4A, 0x4C, 0x4E, 0x50, 0x52, 0x54, 0x56, 0x58, 0x5A, 0x5C, 0x5E,
	0x60, 0x62, 0x64, 0x66, 0x68, 0x6A, 0x6C, 0x6E, 0x70, 0x72, 0x74, 0x76, 0x78, 0x7A, 0x7C, 0x7E,
	0x80, 0x82, 0x84, 0x86, 0x88, 0x8A, 0x8C, 0x8E, 0x90, 0x92, 0x94, 0x96, 0x98, 0x9A, 0x9C, 0x9E,
	0xA0, 0xA2, 0xA4, 0xA6, 0xA8, 0xAA, 0xAC, 0xAE, 0xB0, 0xB2, 0xB4, 0xB6, 0xB8, 0xBA, 0xBC, 0xBE,
	0xC0, 0xC2, 0xC4, 0xC6, 0xC8, 0xCA, 0xCC, 0xCE, 0xD0, 0xD2, 0xD4, 0xD6, 0xD8, 0xDA, 0xDC, 0xDE,
	0xE0, 0xE2, 0xE4, 0xE6, 0xE8, 0xEA, 0xEC, 0xEE, 0xF0, 0xF2, 0xF4, 0xF6, 0xF8, 0xFA, 0xFC, 0xFE,
	0x1B, 0x19, 0x1F, 0x1D, 0x13, 0x11, 0x17, 0x15, 0x0B, 0x09, 0x0F, 0x0D, 0x03, 0x01, 0x07, 0x05,
	0x3B, 0x39, 0x3F, 0x3D, 0x33, 0x31, 0x37, 0x35, 0x2B, 0x29, 0x2F, 0x2D, 0x23, 0x21, 0x27, 0x25,
	0x5B, 0x59, 0x5F, 0x5D, 0x53, 0x51, 0x57, 0x55, 0x4B, 0x49, 0x4F, 0x4D, 0x43, 0x41, 0x47, 0x45,
	0x7B, 0x79, 0x7F, 0x7D, 0x73, 0x71, 0x77, 0x75, 0x6B, 0x69, 0x6F, 0x6D, 0x63, 0x61, 0x67, 0x65,
	0x9B, 0x99, 0x9F, 0x9D, 0x93, 0x91, 0x97, 0x95, 0x8B, 0x89, 0x8F, 0x8D, 0x83, 0x81, 0x87, 0x85,
	0xBB, 0xB9, 0xBF, 0xBD, 0xB3, 0xB1, 0xB7, 0xB5, 0xAB, 0xA9, 0xAF, 0xAD, 0xA3, 0xA1, 0xA7, 0xA5,
	0xDB, 0xD9, 0xDF, 0xDD, 0xD3, 0xD1, 0xD7, 0xD5, 0xCB, 0xC9, 0xCF, 0xCD, 0xC3, 0xC1, 0xC7, 0xC5,
	0xFB, 0xF9, 0xFF, 0xFD, 0xF3, 0xF1, 0xF7, 0xF5, 0xEB, 0xE9, 0xEF, 0xED, 0xE3, 0xE1, 0xE7, 0xE5
};

static const uint8_t GMUL_3[] = {
	0x00, 0x03, 0x06, 0x05, 0x0C, 0x0F, 0x0A, 0x09, 0x18, 0x1B, 0x1E, 0x1D, 0x14, 0x17, 0x12, 0x11,
	0x30, 0x33, 0x36, 0x35, 0x3C, 0x3F, 0x3A, 0x39, 0x28, 0x2B, 0x2E, 0x2D, 0x24, 0x27, 0x22, 0x21,
	0x60, 0x63, 0x66, 0x65, 0x6C, 0x6F, 0x6A, 0x69, 0x78, 0x7B, 0x7E, 0x7D, 0x74, 0x77, 0x72, 0x71,
	0x50, 0x53, 0x56, 0x55, 0x5C, 0x5F, 0x5A, 0x59, 0x48, 0x4B, 0x4E, 0x4D, 0x44, 0x47, 0x42, 0x41,
	0xC0, 0xC3, 0xC6, 0xC5, 0xCC, 0xCF, 0xCA, 0xC9, 0xD8, 0xDB, 0xDE, 0xDD, 0xD4, 0xD7, 0xD2, 0xD1,
	0xF0, 0xF3, 0xF6, 0xF5, 0xFC, 0xFF, 0xFA, 0xF9, 0xE8, 0xEB, 0xEE, 0xED, 0xE4, 0xE7, 0xE2, 0xE1,
	0xA0, 0xA3, 0xA6, 0xA5, 0xAC, 0xAF, 0xAA, 0xA9, 0xB8, 0xBB, 0xBE, 0xBD, 0xB4, 0xB7, 0xB2, 0xB1,
	0x90, 0x93, 0x96, 0x95, 0x9C, 0x9F, 0x9A, 0x99, 0x88, 0x8B, 0x8E, 0x8D, 0x84, 0x87, 0x82, 0x81,
	0x9B, 0x98, 0x9D, 0x9E, 0x97, 0x94, 0x91, 0x92, 0x83, 0x80, 0x85, 0x86, 0x8F, 0x8C, 0x89, 0x8A,
	0xAB, 0xA8, 0xAD, 0xAE, 0xA7, 0xA4, 0xA1, 0xA2, 0xB3, 0xB0, 0xB5, 0xB6, 0xBF, 0xBC, 0xB9, 0xBA,
	0xFB, 0xF8, 0xFD, 0xFE, 0xF7, 0xF4, 0xF1, 0xF2, 0xE3, 0xE0, 0xE5, 0xE6, 0xEF, 0xEC, 0xE9, 0xEA,
	0xCB, 0xC8, 0xCD, 0xCE, 0xC7, 0xC4, 0xC1, 0xC2, 0xD3, 0xD0, 0xD5, 0xD6, 0xDF, 0xDC, 0xD9, 0xDA,
	0x5B, 0x58, 0x5D, 0x5E, 0x57, 0x54, 0x51, 0x52, 0x43, 0x40, 0x45, 0x46, 0x4F, 0x4C, 0x49, 0x4A,
	0x6B, 0x68, 0x6D, 0x6E, 0x67, 0x64, 0x61, 0x62, 0x73, 0x70, 0x75, 0x76, 0x7F, 0x7C, 0x79, 0x7A,
	0x3B, 0x38, 0x3D, 0x3E, 0x37, 0x34, 0x31, 0x32, 0x23, 0x20, 0x25, 0x26, 0x2F, 0x2C, 0x29, 0x2A,
	0x0B, 0x08, 0x0D, 0x0E, 0x07, 0x04, 0x01, 0x02, 0x13, 0x10, 0x15, 0x16, 0x1F, 0x1C, 0x19, 0x1A
};

static const uint8_t GMUL_9[] = {
	0x00, 0x09, 0x12, 0x1B, 0x24, 0x2D, 0x36, 0x3F, 0x48, 0x41, 0x5A, 0x53, 0x6C, 0x65, 0x7E, 0x77,
	0x90, 0x99, 0x82, 0x8B, 0xB4, 0xBD, 0xA6, 0xAF, 0xD8, 0xD1, 0xCA, 0xC3, 0xFC, 0xF5, 0xEE, 0xE7,
	0x3B, 0x32, 0x29, 0x20, 0x1F, 0x16, 0x0D, 0x04, 0x73, 0x7A, 0x61, 0x68, 0x57, 0x5E, 0x45, 0x4C,
	0xAB, 0xA2, 0xB9, 0xB0, 0x8F, 0x86, 0x9D, 0x94, 0xE3, 0xEA, 0xF1, 0xF8, 0xC7, 0xCE, 0xD5, 0xDC,
	0x76, 0x7F, 0x64, 0x6D, 0x52, 0x5B, 0x40, 0x49, 0x3E, 0x37, 0x2C, 0x25, 0x1A, 0x13, 0x08, 0x01,
	0xE6, 0xEF, 0xF4, 0xFD, 0xC2, 0xCB, 0xD0, 0xD9, 0xAE, 0xA7, 0xBC, 0xB5, 0x8A, 0x83, 0x98, 0x91,
	0x4D, 0x44, 0x5F, 0x56, 0x69, 0x60, 0x7B, 0x72, 0x05, 0x0C, 0x17, 0x1E, 0x21, 0x28, 0x33, 0x3A,
	0xDD, 0xD4, 0xCF, 0xC6, 0xF9, 0xF0, 0xEB, 0xE2, 0x95, 0x9C, 0x87, 0x8E, 0xB1, 0xB8, 0xA3, 0xAA,
	0xEC, 0xE5, 0xFE, 0xF7, 0xC8, 0xC1, 0xDA, 0xD3, 0xA4, 0xAD, 0xB6, 0xBF, 0x80, 0x89, 0x92, 0x9B,
	0x7C, 0x75, 0x6E, 0x67, 0x58, 0x51, 0x4A, 0x43, 0x34, 0x3D, 0x26, 0x2F, 0x10, 0x19, 0x02, 0x0B,
	0xD7, 0xDE, 0xC5, 0xCC, 0xF3, 0xFA, 0xE1, 0xE8, 0x9F, 0x96, 0x8D, 0x84, 0xBB, 0xB2, 0xA9, 0xA0,
	0x47, 0x4E, 0x55, 0x5C, 0x63, 0x6A, 0x71, 0x78, 0x0F, 0x06, 0x1D, 0x14, 0x2B, 0x22, 0x39, 0x30,
	0x9A, 0x93, 0x88, 0x81, 0xBE, 0xB7, 0xAC, 0xA5, 0xD2, 0xDB, 0xC0, 0xC9, 0xF6, 0xFF, 0xE4, 0xED,
	0x0A, 0x03, 0x18, 0x11, 0x2E, 0x27, 0x3C, 0x35, 0x42, 0x4B, 0x50, 0x59, 0x66, 0x6F, 0x74, 0x7D,
	0xA1, 0xA8, 0xB3, 0xBA, 0x85, 0x8C, 0x97, 0x9E, 0xE9, 0xE0, 0xFB, 0xF2, 0xCD, 0xC4, 0xDF, 0xD6,
	0x31, 0x38, 0x23, 0x2A, 0x15, 0x1C, 0x07, 0x0E, 0x79, 0x70, 0x6B, 0x62, 0x5D, 0x54, 0x4F, 0x46
};

static const uint8_t GMUL_B[] = {
	0x00, 0x0B, 0x16, 0x1D, 0x2C, 0x27, 0x3A, 0x31, 0x58, 0x53, 0x4E, 0x45, 0x74, 0x7F, 0x62, 0x69,
	0xB0, 0xBB, 0xA6, 0xAD, 0x9C, 0x97, 0x8A, 0x81, 0xE8, 0xE3, 0xFE, 0xF5, 0xC4, 0xCF, 0xD2, 0xD9,
	0x7B, 0x70, 0x6D, 0x66, 0x57, 0x5C, 0x41, 0x4A, 0x23, 0x28, 0x35, 0x3E, 0x0F, 0x04, 0x19, 0x12,
	0xCB, 0xC0, 0xDD, 0xD6, 0xE7, 0xEC, 0xF1, 0xFA, 0x93, 0x98, 0x85, 0x8E, 0xBF, 0xB4, 0xA9, 0xA2,
	0xF6, 0xFD, 0xE0, 0xEB, 0xDA, 0xD1, 0xCC, 0xC7, 0xAE, 0xA5, 0xB8, 0xB3, 0x82, 0x89, 0x94, 0x9F,
	0x46, 0x4D, 0x50, 0x5B, 0x6A, 0x61, 0x7C, 0x77, 0x1E, 0x15, 0x08, 0x03, 0x32, 0x39, 0x24, 0x2F,
	0x8D, 0x86, 0x9B, 0x90, 0xA1, 0xAA, 0xB7, 0xBC, 0xD5, 0xDE, 0xC3, 0xC8, 0xF9, 0xF2, 0xEF, 0xE4,
	0x3D, 0x36, 0x2B, 0x20, 0x11, 0x1A, 0x07, 0x0C, 0x65, 0x6E, 0x73, 0x78, 0x49, 0x42, 0x5F, 0x54,
	0xF7, 0xFC, 0xE1, 0xEA, 0xDB, 0xD0, 0xCD, 0xC6, 0xAF, 0xA4, 0xB9, 0xB2, 0x83, 0x88, 0x95, 0x9E,
	0x47, 0x4C, 0x51, 0x5A, 0x6B, 0x60, 0x7D, 0x76, 0x1F, 0x14, 0x09, 0x02, 0x33, 0x38, 0x25, 0x2E,
	0x8C, 0x87, 0x9A, 0x91, 0xA0, 0xAB, 0xB6, 0xBD, 0xD4, 0xDF, 0xC2, 0xC9, 0xF8, 0xF3, 0xEE, 0xE5,
	0x3C, 0x37, 0x2A, 0x21, 0x10, 0x1B, 0x06, 0x0D, 0x64, 0x6F, 0x72, 0x79, 0x48, 0x43, 0x5E, 0x55,
	0x01, 0x0A, 0x17, 0x1C, 0x2D, 0x26, 0x3B, 0x30, 0x59, 0x52, 0x4F, 0x44, 0x75, 0x7E, 0x63, 0x68,
	0xB1, 0xBA, 0xA7, 0xAC, 0x9D, 0x96, 0x8B, 0x80, 0xE9, 0xE2, 0xFF, 0xF4, 0xC5, 0xCE, 0xD3, 0xD8,
	0x7A, 0x71, 0x6C, 0x67, 0x56, 0x5D, 0x40, 0x4B, 0x22, 0x29, 0x34, 0x3F, 0x0E, 0x05, 0x18, 0x13,
	0xCA, 0xC1, 0xDC, 0xD7, 0xE6, 0xED, 0xF0, 0xFB, 0x92, 0x99, 0x84, 0x8F, 0xBE, 0xB5, 0xA8, 0xA3
};

static const uint8_t GMUL_D[] = {
	0x00, 0x0D, 0x1A, 0x17, 0x34, 0x39, 0x2E, 0x23, 0x68, 0x65, 0x72, 0x7F, 0x5C, 0x51, 0x46, 0x4B,
	0xD0, 0xDD, 0xCA, 0xC7, 0xE4, 0xE9, 0xFE, 0xF3, 0xB8, 0xB5, 0xA2, 0xAF, 0x8C, 0x81, 0x96, 0x9B,
	0xBB, 0xB6, 0xA1, 0xAC, 0x8F, 0x82, 0x95, 0x98, 0xD3, 0xDE, 0xC9, 0xC4, 0xE7, 0xEA, 0xFD, 0xF0,
	0x6B, 0x66, 0x71, 0x7C, 0x5F, 0x52, 0x45, 0x48, 0x03, 0x0E, 0x19, 0x14, 0x37, 0x3A, 0x2D, 0x20,
	0x6D, 0x60, 0x77, 0x7A, 0x59, 0x54, 0x43, 0x4E, 0x05, 0x08, 0x1F, 0x12, 0x31, 0x3C, 0x2B, 0x26,
	0xBD, 0xB0, 0xA7, 0xAA, 0x89, 0x84, 0x93, 0x9E, 0xD5, 0xD8, 0xCF, 0xC2, 0xE1, 0xEC, 0xFB, 0xF6,
	0xD6, 0xDB, 0xCC, 0xC1, 0xE2, 0xEF, 0xF8, 0xF5, 0xBE, 0xB3, 0xA4, 0xA9, 0x8A, 0x87, 0x90, 0x9D,
	0x06, 0x0B, 0x1C, 0x11, 0x32, 0x3F, 0x28, 0x25, 0x6E, 0x63, 0x74, 0x79, 0x5A, 0x57, 0x40, 0x4D,
	0xDA, 0xD7, 0xC0, 0xCD, 0xEE, 0xE3, 0xF4, 0xF9, 0xB2, 0xBF, 0xA8, 0xA5, 0x86, 0x8B, 0x9C, 0x91,
	0x0A, 0x07, 0x10, 0x1D, 0x3E, 0x33, 0x24, 0x29, 0x62, 0x6F, 0x78, 0x75, 0x56, 0x5B, 0x4C, 0x41,
	0x61, 0x6C, 0x7B, 0x76, 0x55, 0x58, 0x4F, 0x42, 0x09, 0x04, 0x13, 0x1E, 0x3D, 0x30, 0x27, 0x2A,
	0xB1, 0xBC, 0xAB, 0xA6, 0x85, 0x88, 0x9F, 0x92, 0xD9, 0xD4, 0xC3, 0xCE, 0xED, 0xE0, 0xF7, 0xFA,
	0xB7, 0xBA, 0xAD, 0xA0, 0x83, 0x8E, 0x99, 0x94, 0xDF, 0xD2, 0xC5, 0xC8, 0xEB, 0xE6, 0xF1, 0xFC,
	0x67, 0x6A, 0x7D, 0x70, 0x53, 0x5E, 0x49, 0x44, 0x0F, 0x02, 0x15, 0x18, 0x3B, 0x36, 0x21, 0x2C,
	0x0C, 0x01, 0x16, 0x1B, 0x38, 0x35, 0x22, 0x2F, 0x64, 0x69, 0x7E, 0x73, 0x50, 0x5D, 0x4A, 0x47,
	0xDC, 0xD1, 0xC6, 0xCB, 0xE8, 0xE5, 0xF2, 0xFF, 0xB4, 0xB9, 0xAE, 0xA3, 0x80, 0x8D, 0x9A, 0x97
};

static const uint8_t GMUL_E[] = {
	0x00, 0x0E, 0x1C, 0x12, 0x38, 0x36, 0x24, 0x2A, 0x70, 0x7E, 0x6C, 0x62, 0x48, 0x46, 0x54, 0x5A,
	0xE0, 0xEE, 0xFC, 0xF2, 0xD8, 0xD6, 0xC4, 0xCA, 0x90, 0x9E, 0x8C, 0x82, 0xA8, 0xA6, 0xB4, 0xBA,
	0xDB, 0xD5, 0xC7, 0xC9, 0xE3, 0xED, 0xFF, 0xF1, 0xAB, 0xA5, 0xB7, 0xB9, 0x93, 0x9D, 0x8F, 0x81,
	0x3B, 0x35, 0x27, 0x29, 0x03, 0x0D, 0x1F, 0x11, 0x4B, 0x45, 0x57, 0x59, 0x73, 0x7D, 0x6F, 0x61,
	0xAD, 0xA3, 0xB1, 0xBF, 0x95, 0x9B, 0x89, 0x87, 0xDD, 0xD3, 0xC1, 0xCF, 0xE5, 0xEB, 0xF9, 0xF7,
	0x4D, 0x43, 0x51, 0x5F, 0x75, 0x7B, 0x69, 0x67, 0x3D, 0x33, 0x21, 0x2F, 0x05, 0x0B, 0x19, 0x17,
	0x76, 0x78, 0x6A, 0x64, 0x4E, 0x40, 0x52, 0x5C, 0x06, 0x08, 0x1A, 0x14, 0x3E, 0x30, 0x22, 0x2C,
	0x96, 0x98, 0x8A, 0x84, 0xAE, 0xA0, 0xB2, 0xBC, 0xE6, 0xE8, 0xFA, 0xF4, 0xDE, 0xD0, 0xC2, 0xCC,
	0x41, 0x4F, 0x5D, 0x53, 0x79, 0x77, 0x65, 0x6B, 0x31, 0x3F, 0x2D, 0x23, 0x09, 0x07, 0x15, 0x1B,
	0xA1, 0xAF, 0xBD, 0xB3, 0x99, 0x97, 0x85, 0x8B, 0xD1, 0xDF, 0xCD, 0xC3, 0xE9, 0xE7, 0xF5, 0xFB,
	0x9A, 0x94, 0x86, 0x88, 0xA2, 0xAC, 0xBE, 0xB0, 0xEA, 0xE4, 0xF6, 0xF8, 0xD2, 0xDC, 0xCE, 0xC0,
	0x7A, 0x74, 0x66, 0x68, 0x42, 0x4C, 0x5E, 0x50, 0x0A, 0x04, 0x16, 0x18, 0x32, 0x3C, 0x2E, 0x20,
	0xEC, 0xE2, 0xF0, 0xFE, 0xD4, 0xDA, 0xC8, 0xC6, 0x9C, 0x92, 0x80, 0x8E, 0xA4, 0xAA, 0xB8, 0xB6,
	0x0C, 0x02, 0x10, 0x1E, 0x34, 0x3A, 0x28, 0x26, 0x7C, 0x72, 0x60, 0x6E, 0x44, 0x4A, 0x58, 0x56,
	0x37, 0x39, 0x2B, 0x25, 0x0F, 0x01, 0x13, 0x1D, 0x47, 0x49, 0x5B, 0x55, 0x7F, 0x71, 0x63, 0x6D,
	0xD7, 0xD9, 0xCB, 0xC5, 0xEF, 0xE1, 0xF3, 0xFD, 0xA7, 0xA9, 0xBB, 0xB5, 0x9F, 0x91, 0x83, 0x8D
};


AESEngine::AESEngine (const AESMode m, const vector<uint8_t>& k)
	: mode(m), key(k)
{
	while (key.size() < keySize()) {
		key.push_back(0);
	}
	if (key.size() > keySize()) {
		key.resize(keySize());
	}

	key = vector<uint8_t>(k.size());
	copy(k.begin(), k.end(), key.begin());

	nrounds = key.size() / 4 + 6;
	schedule = keyExpansion();

	prev = vector<uint8_t>(AES_BLOCK_SIZE);
}


AESEngine::~AESEngine ()
{
	fill(key.begin(), key.end(), 0);
	fill(prev.begin(), prev.end(), 0);
	for (unsigned int b = 0; b < schedule.size(); ++b) {
		for (int k = 0; k < AES_BLOCK_SIZE; ++k) {
			schedule[b][k] = 0;
		}
	}
	nrounds = 0;
}


vector<vector<uint8_t>> AESEngine::keyExpansion ()
{
	int nk = key.size() / 4;
	int ns = 4 * (nrounds + 1);
	vector<vector<uint8_t>> w(ns, vector<uint8_t>(4));
	for (unsigned int k = 0; k < key.size(); ++k) {
		w[k / 4][k % 4] = key[k];
	}
	for (int c = nk; c < ns; ++c) {
		if ((c % nk) == 0) {
			w[c][0] = w[c - nk][0] ^ SBOX[w[c - 1][1]] ^ RCON[c / nk];
			for (int r = 1; r < 4; ++r) {
				w[c][r] = w[c - nk][r] ^ SBOX[w[c - 1][(r + 1) % 4]];
			}
		} else if (nk > 6 && (c % nk) == 4) {
			for (int r = 0; r < 4; ++r) {
				w[c][r] = w[c][r - nk] ^ SBOX[w[c - 1][r]];
			}
		} else {
			for (int r = 0; r < 4; ++r) {
				w[c][r] = w[c][r - nk] ^ w[c - 1][r];
			}
		}
	}
	vector<vector<uint8_t>> sched = 
		vector<vector<uint8_t>>(nrounds + 1, vector<uint8_t>(AES_BLOCK_SIZE));
	for (int b = 0; b < ns / 4; ++b) {
		for (int c = 0; c < 4; ++c) {
			for (int r = 0; r < 4; ++r) {
				sched[b][c * 4 + r] = w[b * 4 + c][r];
			}
		}
	}
	return sched;
}


//                                               m   
//    mmm   m mm    mmm    m mm  m   m  mmmm   mm#mm 
//   #"  #  #"  #  #"  "   #"  " "m m"  #" "#    #   
//   #""""  #   #  #       #      #m#   #   #    #   
//   "#mm"  #   #  "#mm"   #      "#    ##m#"    "mm 
//                                m"    #            
//                               ""     "            


void AESEngine::encryptBlock (uint8_t *block)
{
	if (isModeCBC())
		encryptCBC(block, &prev[0]);
	encryptAddRoundKey(block, &schedule[0][0]);
	for (int r = 0; r < nrounds; ++r) {
		encryptSubBytes(block);
		encryptShiftRows(block);
		encryptMixColumns(block);
		encryptAddRoundKey(block, &schedule[r][0]);
	}
	encryptSubBytes(block);
	encryptShiftRows(block);
	encryptAddRoundKey(block, &schedule[nrounds][0]);
}


void AESEngine::encryptFile (FILE *infile, FILE *outfile)
{
	vector<uint8_t> bufferA(AES_BLOCK_SIZE);
	uint8_t *buf = (uint8_t *)&bufferA[0];
	size_t count = 0;
	bool stopped_at_bounds = true;
	while ((count = fread(buf, 1, AES_BLOCK_SIZE, infile)) > 0) {

		if (count < AES_BLOCK_SIZE) {
			stopped_at_bounds = false;
			uint8_t val = (uint8_t)(AES_BLOCK_SIZE - count);
			while (count < AES_BLOCK_SIZE) {
				bufferA[count] = val;
				++count;
			}
		}

		encryptBlock(buf);
		fwrite(buf, 1, AES_BLOCK_SIZE, outfile);
	}
	if (stopped_at_bounds) {
		for (int k = 0; k < AES_BLOCK_SIZE; ++k) {
			buf[k] = 0x10;
		}
		encryptBlock(buf);
		fwrite(buf, 1, AES_BLOCK_SIZE, outfile);
	}
}


//       #                                       m   
//    mmm#   mmm    mmm    m mm  m   m  mmmm   mm#mm 
//   #" "#  #"  #  #"  "   #"  " "m m"  #" "#    #   
//   #   #  #""""  #       #      #m#   #   #    #   
//   "#m##  "#mm"  "#mm"   #      "#    ##m#"    "mm 
//                                m"    #            
//                               ""     "            


void AESEngine::decryptBlock (uint8_t *block)
{
	decryptAddRoundKey(block, &schedule[nrounds][0]);
	decryptShiftRows(block);
	decryptSubBytes(block);
	for (int r = nrounds - 1; r >= 0; --r) {
		decryptAddRoundKey(block, &schedule[r][0]);
		decryptMixColumns(block);
		decryptShiftRows(block);
		decryptSubBytes(block);
	}
	decryptAddRoundKey(block, &schedule[0][0]);
	if (isModeCBC())
		decryptCBC(block, &prev[0]);
}


void AESEngine::decryptFile (FILE *infile, FILE *outfile)
{
	vector<uint8_t> bufferA(AES_BLOCK_SIZE);
	vector<uint8_t> bufferB(AES_BLOCK_SIZE);
	vector<uint8_t> bufferC(AES_BLOCK_SIZE);
	uint8_t *newest = (uint8_t *)&bufferA[0];
	uint8_t *next   = (uint8_t *)&bufferB[0];
	uint8_t *oldest = (uint8_t *)&bufferC[0];
	size_t nblocks = 0;
	size_t count = 0;
	while ((count = fread(newest, 1, AES_BLOCK_SIZE, infile)) > 0) {
		if (count != AES_BLOCK_SIZE) {
			throw IllegalAESBlockSize();
		}

		++nblocks;

		if (nblocks >= 2) {
			decryptBlock(oldest);
			fwrite(oldest, 1, AES_BLOCK_SIZE, outfile);
		}

		uint8_t *temp = next;
		next = newest;
		oldest = next;
		newest = temp;
	}

	decryptBlock(next);
	uint8_t padding = next[AES_BLOCK_SIZE - 1];
	if (padding < 0x10) {
		fwrite(next, 1, AES_BLOCK_SIZE - padding, outfile);
	}
}

//                 #      mmmmm           m                 
//    mmm   m   m  #mmm   #    # m   m  mm#mm   mmm    mmm  
//   #   "  #   #  #" "#  #mmmm" "m m"    #    #"  #  #   " 
//    """m  #   #  #   #  #    #  #m#     #    #""""   """m 
//   "mmm"  "mm"#  ##m#"  #mmmm"  "#      "mm  "#mm"  "mmm" 
//                                m"                        
//                               ""                         


void AESEngine::encryptSubBytes (uint8_t *block)
{
	for (int k = 0; k < AES_BLOCK_SIZE; ++k) {
		block[k] = SBOX[block[k]];
	}
}


void AESEngine::decryptSubBytes (uint8_t *block)
{
	for (int k = 0; k < AES_BLOCK_SIZE; ++k) {
		block[k] = SBOX_INV[block[k]];
	}
}


//          #        "      m""    m    mmmmm                      
//    mmm   # mm   mmm    mm#mm  mm#mm  #   "#  mmm  m     m  mmm  
//   #   "  #"  #    #      #      #    #mmmm" #" "# "m m m" #   " 
//    """m  #   #    #      #      #    #   "m #   #  #m#m#   """m 
//   "mmm"  #   #  mm#mm    #      "mm  #    " "#m#"   # #   "mmm" 
//


void AESEngine::encryptShiftRows (uint8_t *block)
{
	transpose(block);
	for (int col = 1; col < 4; ++col) {
		uint32_t *t = (uint32_t *)(block + (4 * col));
		*t = rotl(*t, col << 3);
	}
	transpose(block);
}


void AESEngine::decryptShiftRows (uint8_t *block)
{
	transpose(block);
	for (int col = 1; col < 4; ++col) {
		uint32_t *t = (uint32_t *)(block + (4 * col));
		*t = rotr(*t, col << 3);
	}
	transpose(block);
}

//            "             mmm         ""#                               
//   mmmmm  mmm    m   m  m"   "  mmm     #    m   m  mmmmm  m mm    mmm  
//   # # #    #     #m#   #      #" "#    #    #   #  # # #  #"  #  #   " 
//   # # #    #     m#m   #      #   #    #    #   #  # # #  #   #   """m 
//   # # #  mm#mm  m" "m   "mmm" "#m#"    "mm  "mm"#  # # #  #   #  "mmm" 
//


void AESEngine::encryptMixColumns (uint8_t *block)
{
	uint32_t *col = (uint32_t *)block;
	while ((uint8_t *)col < (block + AES_BLOCK_SIZE))
		mixColumn(col++);
}


void AESEngine::decryptMixColumns (uint8_t *block)
{
	uint32_t *col = (uint32_t *)block;
	while ((uint8_t *)col < (block + AES_BLOCK_SIZE))
		mixColumnInv(col++);
}


void AESEngine::mixColumn (uint32_t *col)
{
	uint32_t temp = *col;
	uint8_t *a = (uint8_t *)&temp;
	uint8_t *s = (uint8_t *)col;
	s[0] = GMUL_2[a[0]] ^ GMUL_3[a[1]] ^        a[2]  ^        a[3];
	s[1] =        a[0]  ^ GMUL_2[a[1]] ^ GMUL_3[a[2]] ^        a[3];
	s[2] =        a[0]  ^        a[1]  ^ GMUL_2[a[2]] ^ GMUL_3[a[3]];
	s[3] = GMUL_3[a[0]] ^        a[1]  ^        a[2]  ^ GMUL_2[a[3]];
}

void AESEngine::mixColumnInv (uint32_t *col)
{
	uint32_t temp = *col;
	uint8_t *a = (uint8_t *)&temp;
	uint8_t *s = (uint8_t *)col;
	s[0] = GMUL_E[a[0]] ^ GMUL_B[a[1]] ^ GMUL_D[a[2]] ^ GMUL_9[a[3]];
	s[1] = GMUL_9[a[0]] ^ GMUL_E[a[1]] ^ GMUL_B[a[2]] ^ GMUL_D[a[3]];
	s[2] = GMUL_D[a[0]] ^ GMUL_9[a[1]] ^ GMUL_E[a[2]] ^ GMUL_B[a[3]];
	s[3] = GMUL_B[a[0]] ^ GMUL_D[a[1]] ^ GMUL_9[a[2]] ^ GMUL_E[a[3]];
}


//              #      #  mmmmm                           #  m    m              
//    mmm    mmm#   mmm#  #   "#  mmm   m   m  m mm    mmm#  #  m"   mmm   m   m 
//   "   #  #" "#  #" "#  #mmmm" #" "#  #   #  #"  #  #" "#  #m#    #"  #  "m m" 
//   m"""#  #   #  #   #  #   "m #   #  #   #  #   #  #   #  #  #m  #""""   #m#  
//   "mm"#  "#m##  "#m##  #    " "#m#"  "mm"#  #   #  "#m##  #   "m "#mm"   "#   
//                                                                          m"   
//                                                                         ""    


void AESEngine::encryptAddRoundKey (uint8_t *block, uint8_t *roundkey)
{
	uint_fast32_t *blk = (uint_fast32_t *)block;
	uint_fast32_t *rk  = (uint_fast32_t *)roundkey;
	while ((uint8_t *)blk < (block + AES_BLOCK_SIZE)) {
		*(blk++) ^= *(rk++);
	}
}


void AESEngine::decryptAddRoundKey (uint8_t *block, uint8_t *roundkey)
{
	encryptAddRoundKey(block, roundkey);
}


//     mmm  mmmmm    mmm 
//   m"   " #    # m"   "
//   #      #mmmm" #     
//   #      #    # #     
//    "mmm" #mmmm"  "mmm"
//


void AESEngine::encryptCBC (uint8_t *block, uint8_t *prev)
{
	uint_fast32_t *blk = (uint_fast32_t *)block;
	uint_fast32_t *pr  = (uint_fast32_t *)prev;
	while ((uint8_t *)blk < (block + AES_BLOCK_SIZE)) {
		*blk ^= *pr;
		*pr = *blk;
		++blk;
		++pr;
	}
}


void AESEngine::decryptCBC (uint8_t *block, uint8_t *prev)
{
	uint_fast32_t temp;
	uint_fast32_t *blk = (uint_fast32_t *)block;
	uint_fast32_t *pr = (uint_fast32_t *)prev;
	while ((uint8_t *)blk < (block + AES_BLOCK_SIZE)) {
		temp = *blk;
		*blk ^= *pr;
		*pr = temp;
		++blk;
		++pr;
	}
}


//            m      "    ""#   
//   m   m  mm#mm  mmm      #   
//   #   #    #      #      #   
//   #   #    #      #      #   
//   "mm"#    "mm  mm#mm    "mm 
//


void AESEngine::transpose (uint8_t *block)
{
	for (int c = 0; c < 4; ++c) {
		for (int r = c + 1; r < 4; ++r) {
			swap(block[c * 4 + r], block[r * 4 + c]);
		}
	}
}


vector<uint8_t> AESEngine::loadKey (const char* filename, AESMode m)
{
	FILE *kf = fopen(filename, "rb");
	vector<uint8_t> key(keySize(m));
	if (kf != NULL) {
		size_t count = fread(&key[0], 1, key.size(), kf);
		if (count < key.size()) {

		}
		fclose(kf);
	}
	return key;
}


vector<uint8_t> AESEngine::generateKey ()
{
	return generateKey(mode);
}


vector<uint8_t> AESEngine::generateKey (AESMode m)
{
	vector<uint8_t> key(keySize(m));
	FILE *random = fopen("/dev/urandom", "rb");
	if (random == NULL)
		throw KeyGenerationException("unable to open /dev/urandom");
	if (random != NULL) {
		size_t count = fread(&key[0], 1, key.size(), random);
		if (count != key.size())
			throw KeyGenerationException("unable to create enough entropy");
	}
	return key;
}


bool AESEngine::isModeECB ()
{
	return isModeECB(mode);
}


bool AESEngine::isModeECB (AESMode mode)
{
	return mode <= AESMode::AES_256_ECB;
}


bool AESEngine::isModeCBC ()
{
	return isModeCBC(mode);
}


bool AESEngine::isModeCBC (AESMode mode)
{
	return !isModeECB(mode) && (mode <= AESMode::AES_256_CBC);
}


size_t AESEngine::keySize ()
{
	return keySize(mode);
}


size_t AESEngine::keySize (AESMode mode)
{
	switch (mode) {
		case AESMode::AES_128_ECB:
		case AESMode::AES_128_CBC:
			return 16;
		case AESMode::AES_192_ECB:
		case AESMode::AES_192_CBC:
			return 24;
		case AESMode::AES_256_ECB:
		case AESMode::AES_256_CBC:
			return 32;
		default:
			throw IllegalAESMode();
	}
}
